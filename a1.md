At the start of the assignment, I first read the README.md carefully, then looked through all the methods provided and the methods that needed to be implemented. After looking at the methods, I noticed that the countWords and the countWordsofCertainLength methods are very similar to the solve method from Lab 1, so I decided to use them as a helper method for the assignment. At first, I created a global variable count as a counter to get the total number of words that were found in the boggle, but then, by printing out the words, I noticed that there were duplicates. To prevent duplicates, I was introduced by the UTA to a hashSet class in Java that can help me achieve that goal. Using the hashSet, I was able to avoid duplication by adding all the found words and getting the size of the set. Then, for the isWordInDictionary method, I used the searchPrefix method from the DictInterface to find if the word is a word in the dictionary by checking if res is greater than 0. For the isWordInBroad and markWordInBroad methods, I notice that they are similar because both methods need to search for a specific word through the broad. I used the backtracking framework from lecture to implement a helper method that searches for the word if the tile is not marked, compares each character of the word with the character in the broad, and if it's true, marks the tile and adds the tile to the arrayList. Then, a base case checks if the index equals the word length, and the method returns true as the word is found. If not, keep looking for it by calling the method with the index increased, and then backtracking by removing the tile from the arrayList and unmarking the tile. But when I ran it, the method resulted in a runtime error index out of bounds exception, and I figured out the issue by debugging it. It's because the base case is checked inside the loop, so to resolve the problem, I had the base case put outside the loop and inside the loop check if the recursive call is true, then the method returns true. So having this helper method, I was able to implement isWordInBroad and markWordInBroad methods that can find the specific word for isWordInBroad and add the tiles of the word to an arrayList that the markWordInBroad can use to return. For the two anyWord methods, I noticed that they're very similar to the two count methods, but they return a string instead of an integer, so I used a similar way to implement them. Finally, for the checkTiles method, I notice that the ultimate goal of it is to check if the arrayList of tiles in the broad is the word that is looking, so I just append all characters in the broad of the corresponding tiles to a stringBuilder and compare it with the word. For the worst-case runtime of the methods, it's based on the number of words in the dictionary, the number of characters in a word, and the board size. I think if I let the maximum length of the dictionary be m, the number of characters in a word be n, and for the broad size, let the size be b^2, then the worst case should be all of them multiplying together, O(m*n*b^2) but the methods also used backtraking algorithm that has a runtime of 
O(n*8^n), since the searching space size of the boggle game is number of nodes * work per node, so in my conclusion the worse runtime for a method is O(m*n*b^2*b*8^b) = O(m*n*b^2*8^b).

